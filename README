
                                     RSH

1. Overview

    RSH is meant to be as close to bash syntax as possible. However, since I am
human, attented university, and am not a CS major, there is only so much I
could do. RSH consists of several main parts that work together to create what
someone might call a 'shell'. The parts are as follows: a terminal interface, a
lexxer -- generated by `flex', a parser, a command interpretter, and finally
an exec() syscall interface. Each of these sections contribute to the flow of
command -> action.
    There are also some other nice features that will be discussed such as the
symbol table and the environment table.

2. The Terminal Interface.

    In order to have some of the most basic of shell behaviors, a terminal
interface is required. In general, a programmer would not reinvent the wheel
and use a library like gnu-term-readline, which supports history, sophisticated
command line editing, basic tab completion, etc. However, as wonderful as
gnu-term-readline is, it would not fulfill the project requirements, so instead
I wrote my own simplified version of gnu-term-readline. The results are in the
source file src/readterm.c. Essentially, one must read each byte of the input
stream and process said byte. If an escape character is detected then a special
handler for the following escape sequence must be called. This is implemented
in the function _rsh_handle_escape_seq(). This function deals with all
understood escape sequences. It has sub handlers for particular escape
sequences such as the up arrow key or the DEL key. These sequences are handled
by: _rsh_do_history_completion(), _rsh_do_move_cursor(), _rsh_do_delete(). As
of now the following non printing characters or sequences can be processed:
DEL, the arrow keys, backspace (ASCII 0x7f).
    Terminal history is handled in this section of the code as well. All of the
incoming data is stored into buffers, These buffers are implemented via

    struct rsh_buff {

      /* The underlying buffer itself. */
      char *buf;

      /* The offset to write the next character to. */
      int offset; 

      /* The number of characters in the buffer. */
      int len;
	    
      /* The size of the buffer. */
      int size;

      /* Does this buffer have stuff? */
      int used;

    };

This data type is used to effectively keep track of what has been typed, which
allows us to redisplay the terminal data with a cursor location so editing can
be performed in arbitrary places in the data (also implies left/right arrow
keys, del, backspace). The history itself is a circular buffer of just the text
in a buffer. The buffer itself can be regenerated from the history so that the
history can be edited once placed on the command line vie the up/down arrow 
keys. However, the history itself is not changed, just the temporary buffer
holding a copy of the history item.
    History itself is implemented as a circular buffer of pointers to pointers
to char:

    char *history[_HIST_BUFFER_SIZE];

This allows extremely efficient usage of memory since there is only 1 pointer
worth of overhead: the pointer that delimits the end of the table. If the 
history is full, then the end pointer is simply incremented and the first entry
put into the history will be replaced. In that regard the history is like a 
FIFO queue. The strings themselves are stored on the heap via malloc() via 
strdup().
    The readline functionality must be able to interface with the lexxer 
generated by `flex'. In order to do this, the `flex' input macro

    YY_INPUT(buf, result, max_size)

had to be overwridden. This is done by defining a macro in the parser.lex
preamble code. The function that this macro uses is defined in src/readterm.c
as 
    rsh_readbuf(char *buffer, size_t max)

This function must translate between line reading (which is what we do on the
terminal) and buffer reading which is what `flex' does. Flex will attempt to 
read at most max characters. However, if for whatever reason, the user has 
typed in more than 'max' characters, read_buf must be able to handle this.
read_buf() must also be able to handle reading from a file; as such read_buf()
really just determines what actual function to call based on whether the shell
is interactive or not. For more information regarding this code, peruse the
lex.yy.c (this is the generated lexxer) and the parser.lex files.


3. The Parser

    RSH's parser really sucks. I tried to implement something via yacc but
realized that would not work since I didn't really understand how to write a
proper grammer. As such instead of implementing my own shift reduce parser or
the like, I write a really simple, bad, and at least mostly functional parser.
Since it is completely adhoc'ish code, it does not support all the cool things
that a real shell like ZSH supports. But it gets the job done. That code is all
int parser.c.

4. Command Interpretter

    The command interpretter is a fairly simple block of code. It reads through
each passed command and figures out what to do: varible declarations, commands,
background or foreground, builtins, etc. Once it knows what to do, it asks the
exec block of code to actualyl do it. The command interpretter is in command.c.

5. Exec()...

    The first thing I want to say is this code was not easy to debug. Nor was
the documentation all that good. The GNU libc documentation (and example shell)
was an invaluable reasource. In any event, the basic idea is this, rsh needs to
make sure it is in its own process group, this has to do with signal handling.
When a signal is passed to a child process, rsh does not want to get that
signal as well (unless we are running as a script, but we will ge to that in a
bit). In general, rsh really only wants to get a few signals from the children:
SIGCHLD primarily. This allows the wait() syscall and friends to get 
notifications about child state changes. This is crucial for the shell.
    RSH keeps track of all child processes via the following data structure:

    struct rsh_process_group {

      /* List related stuff. */
      struct rsh_process **pgroup;
      int max_procs;

      /* The standard I/O streams that point to the controlling terminal. Or a 
       * pipe if configured that way, but these should never not be 0, 1, & 2.*/
      int stdin;
      int stdout;
      int stderr;
  
      /* The pid of the shell. Why not? */
      pid_t pid;

      /* The process group ID for the shell's process group. */
      gid_t pgid;

    };

This struct has a list of processes. These processes are tracked via the 
following data type:

    struct rsh_process {

      /* Process ID and process group ID. */
      pid_t pid;
      gid_t pgid;
      
      /* Process' standard I/O streams. */
      int stdin;
      int stdout;
      int stderr;

      /* Zero if this process is in the foreground. */
      int background;
  
      /* Non-zero if the process is actually running. */
      int running;

      /* The first 128 chars (if there are that many) of the commands actual
       * file name (i.e: /usr/bin/ping). */
      char name[128];

      /* Terminal settings. */
      struct termios term;

      /* These will probably not remain valid forever, but as long as they last
       * up to the fork() call, they will be good for the child process to use.
       */
      char *command;
      char **argv;
      int argc;

    };

Each process that gets spawned gets its own struct rsh_process allocated. This
allows rsh to keep track of background processes. The builtin command `dproc'
displays the list of currently running/paused processes.
    By using the proces list, jobs can be controlled fairly easily. Each
spawned process is put into its own process group. This isn't what should
happen, each group of process making up a job should be given the same process 
group, but as of now, that isn't implemented. In any event, the exec.c code
implements typical job control. For example, given a program called run that
just sits in a for (;;); loop:

    [rsh]$ /home/alex/tmp/run
    CTRL-z
    Process (4786) stopped [sig=20].
    [rsh]$ bg
    [rsh]$ dproc
    pid 4767  (running): rsh
    pid 4786  (running): /home/alex/tmp/run
    [rsh]$ killall -SIGSTOP run
    + stopped             /home/alex/tmp/run
    [rsh]$ dproc
    pid 4767  (running): rsh
    pid 4786  (stopped): /home/alex/tmp/run
    [rsh]$ fg

    Process (4786) terminated by signal.
    [rsh]$ dproc
    pid 4767  (running): rsh

In any event, as can be seen, the process run (pid=4786) was started normally,
got a SIGTSTP (Terminal stop) from the CTRL-z, got backgrounded, then got
stopped via a killall -SIGSTOP, was foregrounded again, and finally killed with
a CTRL-c. The dproc command was used to display the contents of the rsh shells
process list. However, to really see this in action, open up another shell
even rsh would work for this) and run top. Now you will be able to see the 
process use the cpu when its running.
    Outside of the shell signals were returned to normal, that is to say CTRL-c
does not print the shell history if the shell is not the foreground. This also
allows us to kill a process that we don't like without having to open another
shell.

6. The Symbol Table and Environment.

    Like all shells, rsh supports the defining of scalar variables. However
there are some limitations that should be noted. Here is a basic example of a
scalar definition:

    [rsh]$ PROMPT='[rsh]$ '
    
This sets the $PROMPT variable to '[rsh]$ '. $PROMPT is used by rsh to generate
the prompt. In any event, this adds a symbol to the rsh symbol table. This
symbol can be used later on like so:

    [rsh]$ echo $PROMPT
    [rsh]$ 
    
Again this is just typical shell behavior. However, some more complex examples
will not work the way you expect them to. For instance:

    [rsh]$ echo blah=10
    
    [rsh]$ 

This occurs because variable definitions may occur anywhere in the command 
line. In the ZSH shell however, you would see something like this:

    [11:35AM alex@australia src]$ echo blah=10
    blah=10
    [11:38AM alex@australia src]$

    The symbol table used by rsh also interfaces with the environment list that
libc maintains. If you try and use a variable that is in the enviroment, the
environment variable will be chosen over the symbol tabel definition. For
instance:

    [rsh]$ PATH=$PATH:/my/new/path
    [rsh]$ echo $PATH
    /usr/local/bin:/usr/bin:/bin:/home/alex/bin:/usr/local/sbin:/usr/sbin:/sbin
    :/my/new/path
    [rsh]$

This is a rather useful feature, especially since the environment varibles
carry over into sub processes:

    [rsh]$ PATH=$PATH:/my/new/path
    [rsh]$ env
    ...
    PATH=/usr/local/bin:/usr/bin:/bin:/home/alex/bin:/usr/local/sbin:/usr/sbin:
    /sbin:/my/new/path
    [rsh]$ 

There are a few limitations to dealing with variables. Don't try to export a
symbol from the symbol table to the environment at the same time you try and
define it.

    [rsh]$ export BLAH="hello world"

This will not work the way you expect it to. Instead:
    
    [rsh]$ BLAH="hello world"
    [rsh]$ export BLAH

